// whitespace
BLANK = _{ " " | "\t" }
WHITESPACE = _{ BLANK | NEWLINE }
// comments
line_comment = { "#" ~ (!NEWLINE ~ ANY)* ~ (NEWLINE | EOI) }
block_comment = { "/*" ~ ANY* ~ "*/" }
COMMENT = _{ block_comment | line_comment }

ident = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

int_hex = @{ "0x" ~ (ASCII_HEX_DIGIT | "_")+ }
int_oct = @{ "0o" ~ ('0'..'7' | "_")+ }
int_bin = @{ "0b" ~ ("0" | "1" | "_")+ }
int = @{ int_hex | int_oct | int_bin | (ASCII_DIGIT | "_")+ }

float_hex = @{ "0x" ~ ((ASCII_HEX_DIGIT | "_")* ~ "." ~ (ASCII_HEX_DIGIT | "_")+) | ((ASCII_HEX_DIGIT | "_")+ ~ "." ~ (ASCII_HEX_DIGIT | "_")*) }
float_oct = @{ "0o" ~ (('0'..'7' | "_")* ~ "." ~ ('0'..'7' | "_")+) | (('0'..'7' | "_")+ ~ "." ~ ('0'..'7' | "_")*) }
float_bin = @{ "0b" ~ (("0" | "1" | "_")* ~ "." ~ ("0" | "1" | "_")+) | (("0" | "1" | "_")+ ~ "." ~ ("0" | "1" | "_")*) }
float = @{ float_hex | float_oct | float_bin }

raw_char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}
char_inner = @{ raw_char }
char = ${ "'" ~ char_inner ~ "'" }

string_inner = @{ raw_char* }
string = ${ "\"" ~ string_inner ~ "\"" }

bool = { "true" | "false" }

tuple = { "(" ~ (expr ~ "," )+ ~ expr ~ ")" }
array = { "[" ~ (expr ~ ",")+ ~ expr ~ "]" }

type_binary_op = { "&" | "|" }
type_binary_expr = { ("(" ~ type_expr ~ ")" | type_literal) ~ (type_binary_op ~ type_expr)+ }

type_tuple = { "(" ~ (type_expr ~ ",")*  ~ type_expr ~ ")"}
type_unary_op = { "[]" }
type_unary_expr = { ("(" ~ ")" | type_literal) ~ type_unary_op }

type_literal = { type_tuple | ident }

type_expr = {
	type_binary_expr
    | type_unary_expr
    | ident
}

literal = { tuple | string | char | bool | array | float | int }

expr = ${ conditional_stmt | func_call | binary_expr | unary_expr | literal | ident }

mut_token = { "mut" }
let_declaration = !{ "let" ~ (mut_token? ~ ident ~ ",")* ~ mut_token? ~ ident ~ "=" ~ (expr ~ ",")* ~ expr }
mut_declaration = !{ mut_token ~ (ident? ~ ",")* ~ ident ~ "=" ~ (expr ~ ",")* ~ expr }
declaration = _{ let_declaration | mut_declaration }

block = !{ "{" ~ statement* ~ "}" }

if_stmt = !{ "if" ~ expr ~ block }
else_stmt = !{ "else" ~ block }
else_if_stmt = !{ "else" ~ "if" ~ expr ~ block }
conditional_stmt = !{ if_stmt ~ else_if_stmt* ~ else_stmt? }

loop_stmt = !{ "loop" ~ ident? ~ block }
while_stmt = !{ "while" ~ expr ~ block }
break_stmt = !{ "break" ~ ident? }

unary_op_prefix = {
	"~"
	| "!"
	| "&"
	| "*"
}

unary_op_suffix = {
	"++"
	| "--"
}

unary_expr_inner = _{ ("(" ~ expr ~ ")") | literal | ident }
unary_expr = !{ 
	(unary_op_prefix? ~ unary_expr_inner ~ unary_op_suffix) 
	| (unary_op_prefix ~ unary_expr_inner ~ unary_op_suffix?) 
}

// define all binary operation rules
// length 3 operators
binary_op_logical_and_eq = { "&&=" }
binary_op_logical_or_eq = { "||=" }
binary_op_lshift_eq = { "<<=" }
binary_op_rshift_eq = { ">>=" }
binary_op_pow_eq = { "**=" }
// length 2 operators
binary_op_and_eq = { "&=" }
binary_op_as = { "as" }
binary_op_bitwise_and_eq = { "&=" }
binary_op_bitwise_not_eq = { "~=" }
binary_op_bitwise_or_eq = { "|=" }
binary_op_bitwise_xor_eq = { "^=" }
binary_op_div_eq = { "/=" }
binary_op_eq = { "==" }
binary_op_ge = { ">=" }
binary_op_le = { "<=" }
binary_op_logical_and = { "&&" }
binary_op_logical_or = { "||" }
binary_op_lshift = { "<<" }
binary_op_minus_eq = { "-=" }
binary_op_mod_eq = { "%=" }
binary_op_mul_eq = { "*=" }
binary_op_ne = { "!=" }
binary_op_not_eq = { "!=" }
binary_op_or_eq = { "|=" }
binary_op_plus_eq = { "+=" }
binary_op_rshift = { ">>" }
binary_op_xor_eq = { "^=" }
binary_op_pow = { "**" }
// length 1 operators
binary_op_add = { "+" }
binary_op_bitwise_and = { "&" }
binary_op_bitwise_or = { "|" }
binary_op_bitwise_xor = { "^" }
binary_op_div = { "/" }
binary_op_gt = { ">" }
binary_op_lt = { "<" }
binary_op_mod = { "%" }
binary_op_mul = { "*" }
binary_op_sub = { "-" }


binary_op = {
	binary_op_lshift_eq
	| binary_op_rshift_eq
	| binary_op_logical_and_eq
	| binary_op_logical_or_eq
	| binary_op_and_eq
	| binary_op_bitwise_and_eq
	| binary_op_bitwise_not_eq
	| binary_op_bitwise_or_eq
	| binary_op_bitwise_xor_eq
	| binary_op_div_eq
	| binary_op_eq
	| binary_op_ge
	| binary_op_le
	| binary_op_logical_and
	| binary_op_logical_or
	| binary_op_minus_eq
	| binary_op_mod_eq
	| binary_op_mul_eq
	| binary_op_ne
	| binary_op_not_eq
	| binary_op_or_eq
	| binary_op_plus_eq
	| binary_op_xor_eq
	| binary_op_add
	| binary_op_bitwise_and
	| binary_op_bitwise_or
	| binary_op_bitwise_xor
	| binary_op_div
	| binary_op_gt
	| binary_op_lt
	| binary_op_mod
	| binary_op_mul
	| binary_op_sub
}

binary_expr = { ("(" ~ expr ~ ")" | ident) ~ (binary_op ~ expr)+ }

func_decl_generics = !{ "<" ~ (ident ~ ("extends" ~ ident)? ~ ",")* ~ ident ~ ("extends" ~ ident)? ~ ">" }
func_decl_params = !{ (ident ~ ":" ~ ident ~ ",")* ~ ident ~ ":" ~ ident }
func_decl = !{ ident ~ func_decl_generics? ~ func_decl_params? ~ "->" ~ (block | expr) }

extern_func_decl = !{ "extern" ~ ident ~ func_decl_params? ~ "->" ~ ident }

func_call_params = @{ ((expr ~ ",")* ~ expr) | "()" }
func_call = @{ ident ~ func_call_params }

func_return = !{ "return" ~ expr }
func_defer = !{ "defer" ~ expr }

statement_inner = {
	conditional_stmt
	| loop_stmt
	| while_stmt
	| declaration
	| func_decl
	| extern_func_decl
	| func_defer
	| func_return
	| break_stmt
	| binary_expr
	| unary_expr
	| func_call
}

statement = @{ statement_inner ~ BLANK* ~ ";"? ~ BLANK* ~ NEWLINE* }

styx = @{ SOI ~ statement* ~ EOI }
